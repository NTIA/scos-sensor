version: '3'

services:
  api:
    healthcheck:
      test: test ! -e /usrp_unhealthy
      interval: 10s
      timeout: 1s
      retries: 1
    restart: always
    labels:
      autoheal: "true"  # allow docker-autoheal to restart if unhealthy
    image: ntiaits/test_scossensor_api
    environment:
      - DEBUG
      - DOMAINS
      - IPS
      - SECRET_KEY
      - GUNICORN_LOG_LEVEL
    expose:
      - '8000'
    volumes:
      - ../db.sqlite3:/db.sqlite3
      - /opt/scos:/opt/scos
    devices:
      - /dev/bus/usb:/dev/bus/usb:rw
    command: /docker/api_entrypoint.sh

  nginx:
    image: ${NGINX_IMAGE}
    restart: always
    ports:
      - '80:80'
      - '443:443'
    volumes:
      - ../nginx/conf.d:/etc/nginx/conf.d:ro
      - ../src/static:/var/www/scos-sensor/static:ro
      - ${SSL_CERT_PATH}:/etc/ssl/certs/ssl-cert.pem:ro
      - ${SSL_KEY_PATH}:/etc/ssl/private/ssl-cert.key:ro

  # This is a stop-gap until Docker adds the capability to restart unhealthy
  # containers natively. This container mounts the host's docker unix socket,
  # which in theory introduces a root privilege escalation vector, but since
  # this image isn't internet-facing, it's Probably Okay (tm), and definitely
  # a better temporary solution than mounting the socket directly in the api
  # container.
  #
  # https://github.com/moby/moby/issues/28400
  # https://github.com/willfarrell/docker-autoheal
  # autoheal:
  #   image: ${UBUNTU_IMAGE}
  #   restart: on-failure
  #   depends_on:
  #     - api
  #   volumes:
  #     - /var/run/docker.sock:/var/run/docker.sock
  #     - ./autoheal_entrypoint.sh:/docker/autoheal_entrypoint.sh:ro
  #   command: /docker/autoheal_entrypoint.sh

  ws_logger:
    restart: always
    image: gliderlabs/logspout
    expose:
      - '80'
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
